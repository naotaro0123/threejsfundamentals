<!DOCTYPE html>
<!-- this file is auto-generated from threejs/lessons/ru/threejs-optimize-lots-of-objects-animated.md. Do not edited directly -->
<!--
Copyright 2018, Google Inc.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of Google Inc. nor the names of their
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Анимированные объединенные объекты с морфтаргетами">
<meta name="keywords" content="webgl graphics three.js">
<meta name="thumbnail" content="https://threejsfundamentals.org/threejs/lessons/screenshots/threejs-optimize-lots-of-objects-animated_ru.jpg">

<meta property="og:title" content="Three.js Оптимизация большого количества анимированных объектов">
<meta property="og:type" content="website">
<meta property="og:image" content="https://threejsfundamentals.org/threejs/lessons/screenshots/threejs-optimize-lots-of-objects-animated_ru.jpg">
<meta property="og:description" content="Анимированные объединенные объекты с морфтаргетами">
<meta property="og:url" content="https://threejsfundamentals.org/threejs/lessons/ru/threejs-optimize-lots-of-objects-animated.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="threejsfundamentals.org">
<meta name="twitter:title" content="Three.js Оптимизация большого количества анимированных объектов">
<meta name="twitter:url" content="https://threejsfundamentals.org/threejs/lessons/ru/threejs-optimize-lots-of-objects-animated.html">
<meta name="twitter:description" content="Анимированные объединенные объекты с морфтаргетами">
<meta name="twitter:image:src" content="https://threejsfundamentals.org/threejs/lessons/screenshots/threejs-optimize-lots-of-objects-animated_ru.jpg">

  <link rel="alternate" hreflang="en" href="https://webglfundamentals.org/threejs/lessons/threejs-optimize-lots-of-objects-animated.html">
  <link rel="alternate" hreflang="fr" href="https://webglfundamentals.org/threejs/lessons/fr/threejs-optimize-lots-of-objects-animated.html">
  <link rel="alternate" hreflang="ja" href="https://webglfundamentals.org/threejs/lessons/ja/threejs-optimize-lots-of-objects-animated.html">
  <link rel="alternate" hreflang="kr" href="https://webglfundamentals.org/threejs/lessons/kr/threejs-optimize-lots-of-objects-animated.html">
  <link rel="alternate" hreflang="ru" href="https://webglfundamentals.org/threejs/lessons/ru/threejs-optimize-lots-of-objects-animated.html">
  <link rel="alternate" hreflang="zh_cn" href="https://webglfundamentals.org/threejs/lessons/zh_cn/threejs-optimize-lots-of-objects-animated.html">




<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://threejsfundamentals.org/#website",
      "url":"https://threejsfundamentals.org/",
      "name":"ThreejsFundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://threejsfundamentals.org/threejs/lessons/ru/threejs-optimize-lots-of-objects-animated.html#primaryimage",
      "url":"https://threejsfundamentals.org/threejs/lessons/screenshots/threejs-optimize-lots-of-objects-animated_ru.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://threejsfundamentals.org/threejs/lessons/ru/threejs-optimize-lots-of-objects-animated.html#webpage",
      "url":"https://threejsfundamentals.org/threejs/lessons/ru/threejs-optimize-lots-of-objects-animated.html",
      "inLanguage":"ru",
      "name":"Three.js Оптимизация большого количества анимированных объектов",
      "keywords":"webgl graphics three.js programming",
      "isPartOf":{
        "@id":"https://threejsfundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://threejsfundamentals.org/threejs/lessons/ru/threejs-optimize-lots-of-objects-animated.html#primaryimage"
      }
    }
  ]
}
</script>

<title>Three.js Оптимизация большого количества анимированных объектов</title>
<link href="/threejs/lessons/resources/threejsfundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="apple-touch-icon" href="/threejs/lessons/resources/threejsfundamentals-icon.png">
<link rel="icon" href="/threejs/lessons/resources/threejsfundamentals-icon.png">

<link rel="stylesheet" href="/threejs/lessons/lang.css">
<link rel="stylesheet" href="/threejs/lessons/resources/lesson.css">
</head>
<body>
<div class="threejs_navbar">
  <div>
    <select class="language">
    <option value="/threejs/lessons/threejs-optimize-lots-of-objects-animated.html" >English</a>
    <option value="/threejs/lessons/fr/threejs-optimize-lots-of-objects-animated.html" >Français</a>
    <option value="/threejs/lessons/ja/threejs-optimize-lots-of-objects-animated.html" >日本語</a>
    <option value="/threejs/lessons/kr/threejs-optimize-lots-of-objects-animated.html" >한국어</a>
    <option value="/threejs/lessons/ru/threejs-optimize-lots-of-objects-animated.html" selected>Русский</a>
    <option value="/threejs/lessons/zh_cn/threejs-optimize-lots-of-objects-animated.html" >中文</a>
</select>


    <a href="#toc">Оглавление</a>
  </div>
</div>
<div class="threejs_header">
  <h1><a href="/threejs/lessons/ru/">threejsfundamentals.org</a></h1>
<style>
#forkongithub a {
    background: #000;
    color: #fff;
    text-decoration: none;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 2rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 300px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(150px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a:hover {
    background: #c11;
    color: #fff;
}
#forkongithub a::before,#forkongithub a::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub a::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
@media (max-width: 900px) {
    #forkongithub a{
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub a{
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub"><a href="https://github.com/gfxfundamentals/threejsfundamentals">Fix, Fork, Contribute <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"/>
    </g>
</svg>
</a></div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>Three.js Оптимизация большого количества анимированных объектов</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>Эта статья является продолжением  <a href="threejs-optimize-lots-of-objects.html">статьи об оптимизации множества объектов
</a>. Если вы еще не прочитали это, пожалуйста, прочитайте его, прежде чем продолжить.  </p>
<p>В предыдущей статье мы объединили около 19000 кубов в одну геометрию. Это имело преимущество, заключающееся в том, 
что оно оптимизировало наш рисунок из 19000 кубов, но имело тот недостаток, что затрудняло перемещение любого отдельного куба. </p>
<p>В зависимости от того, чего мы пытаемся достичь, существуют разные решения. В этом случае давайте наметим несколько наборов данных и анимируем между наборами. </p>
<p>Первое, что нам нужно сделать, это получить несколько наборов данных. 
В идеале мы бы, вероятно, предварительно обрабатывали данные в автономном режиме, 
но в этом случае давайте загрузим 2 набора данных и сгенерируем еще 2 </p>
<p>Вот наш старый код загрузки </p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">loadFile(&#39;resources/data/gpw/gpw_v4_basic_demographic_characteristics_rev10_a000_014mt_2010_cntm_1_deg.asc&#39;)
  .then(parseData)
  .then(addBoxes)
  .then(render);
</code></pre>
<p>Давайте изменим это на что-то вроде этого </p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">async function loadData(info) {
  const text = await loadFile(info.url);
  info.file = parseData(text);
}

async function loadAll() {
  const fileInfos = [
    {name: &#39;men&#39;,   hueRange: [0.7, 0.3], url: &#39;resources/data/gpw/gpw_v4_basic_demographic_characteristics_rev10_a000_014mt_2010_cntm_1_deg.asc&#39; },
    {name: &#39;women&#39;, hueRange: [0.9, 1.1], url: &#39;resources/data/gpw/gpw_v4_basic_demographic_characteristics_rev10_a000_014ft_2010_cntm_1_deg.asc&#39; },
  ];

  await Promise.all(fileInfos.map(loadData));

  ...
}
loadAll();
</code></pre>
<p>Приведенный выше код загрузит все файлы в <code class="notranslate" translate="no">fileInfos</code>, и после этого каждый объект в <code class="notranslate" translate="no">fileInfos</code>
будет иметь свойство <code class="notranslate" translate="no">file</code> с загруженным файлом. <code class="notranslate" translate="no">name</code> и <code class="notranslate" translate="no">hueRange</code> мы будем использовать позже. 
<code class="notranslate" translate="no">name</code> будет для поля пользовательского интерфейса. <code class="notranslate" translate="no">hueRange</code> будет использоваться для выбора диапазона оттенков для отображения. </p>
<p>Два файла выше, по-видимому, представляют собой количество мужчин на область и число женщин на область по состоянию на 2010 год. Обратите внимание,
я не знаю, верны ли эти данные, но на самом деле это не важно. Важная часть показывает разные наборы данных. </p>
<p>Давайте сгенерируем еще 2 набора данных. Одним из них являются места, 
где число мужчин превышает число женщин, и наоборот, места, где число женщин превышает число мужчин. </p>
<p>Первым делом давайте напишем функцию, которая с помощью двухмерного массива массивов, 
как мы делали раньше, отобразит ее, чтобы сгенерировать новый двумерный массив массивов. </p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function mapValues(data, fn) {
  return data.map((row, rowNdx) =&gt; {
    return row.map((value, colNdx) =&gt; {
      return fn(value, rowNdx, colNdx);
    });
  });
}
</code></pre>
<p>Как и обычная функция <code class="notranslate" translate="no">Array.map</code>, функция <code class="notranslate" translate="no">mapValues</code> вызывает функцию fn для каждого значения в массиве массивов. 
Он передает ему значение, а также индексы строки и столбца. </p>
<p>Теперь давайте создадим некоторый код для генерации нового файла, который сравнивает 2 файла. </p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function makeDiffFile(baseFile, otherFile, compareFn) {
  let min;
  let max;
  const baseData = baseFile.data;
  const otherData = otherFile.data;
  const data = mapValues(baseData, (base, rowNdx, colNdx) =&gt; {
    const other = otherData[rowNdx][colNdx];
      if (base === undefined || other === undefined) {
        return undefined;
      }
      const value = compareFn(base, other);
      min = Math.min(min === undefined ? value : min, value);
      max = Math.max(max === undefined ? value : max, value);
      return value;
  });
  // make a copy of baseFile and replace min, max, and data
  // with the new data
  return {...baseFile, min, max, data};
}
</code></pre>
<p>Приведенный выше код использует <code class="notranslate" translate="no">mapValues</code> для генерации нового набора данных, 
который представляет собой сравнение на основе переданной функции <code class="notranslate" translate="no">CompareFn</code>. 
Он также отслеживает минимальные и максимальные результаты сравнения. Наконец, 
он создает новый файл со всеми теми же свойствами, что и <code class="notranslate" translate="no">baseFile</code>, за исключением новых <code class="notranslate" translate="no">min</code>, <code class="notranslate" translate="no">max</code> и <code class="notranslate" translate="no">data</code>. </p>
<p>Тогда давайте использовать это, чтобы сделать 2 новых набора данных </p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">{
  const menInfo = fileInfos[0];
  const womenInfo = fileInfos[1];
  const menFile = menInfo.file;
  const womenFile = womenInfo.file;

  function amountGreaterThan(a, b) {
    return Math.max(a - b, 0);
  }
  fileInfos.push({
    name: &#39;&gt;50%men&#39;,
    hueRange: [0.6, 1.1],
    file: makeDiffFile(menFile, womenFile, (men, women) =&gt; {
      return amountGreaterThan(men, women);
    }),
  });
  fileInfos.push({
    name: &#39;&gt;50% women&#39;, 
    hueRange: [0.0, 0.4],
    file: makeDiffFile(womenFile, menFile, (women, men) =&gt; {
      return amountGreaterThan(women, men);
    }),
  });
}
</code></pre>
<p>Теперь давайте сгенерируем пользовательский интерфейс для выбора между этими наборами данных. Для начала нам нужен HTML-интерфейс </p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-html">&lt;body&gt;
  &lt;canvas id=&quot;c&quot;&gt;&lt;/canvas&gt;
+  &lt;div id=&quot;ui&quot;&gt;&lt;/div&gt;
&lt;/body&gt;
</code></pre>
<p>и немного CSS, чтобы он появился в верхней левой области </p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-css">#ui {
  position: absolute;
  left: 1em;
  top: 1em;
}
#ui&gt;div {
  font-size: 20pt;
  padding: 1em;
  display: inline-block;
}
#ui&gt;div.selected {
  color: red;
}
</code></pre>
<p>Затем мы можем просмотреть каждый файл и сгенерировать набор объединенных блоков
для набора данных и элемент, который при наведении курсора отобразит этот набор и скроет все остальные.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// show the selected data, hide the rest
function showFileInfo(fileInfos, fileInfo) {
  fileInfos.forEach((info) =&gt; {
    const visible = fileInfo === info;
    info.root.visible = visible;
    info.elem.className = visible ? &#39;selected&#39; : &#39;&#39;;
  });
  requestRenderIfNotRequested();
}

const uiElem = document.querySelector(&#39;#ui&#39;);
fileInfos.forEach((info) =&gt; {
  const boxes = addBoxes(info.file, info.hueRange);
  info.root = boxes;
  const div = document.createElement(&#39;div&#39;);
  info.elem = div;
  div.textContent = info.name;
  uiElem.appendChild(div);
  div.addEventListener(&#39;mouseover&#39;, () =&gt; {
    showFileInfo(fileInfos, info);
  });
});
// show the first set of data
showFileInfo(fileInfos, fileInfos[0]);
</code></pre>
<p>Еще одно изменение, которое нам нужно из предыдущего примера, заключается в том, что мы должны заставить <code class="notranslate" translate="no">addBoxes</code> принимать <code class="notranslate" translate="no">hueRange</code> </p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">-function addBoxes(file) {
+function addBoxes(file, hueRange) {

  ...

    // compute a color
-    const hue = THREE.MathUtils.lerp(0.7, 0.3, amount);
+    const hue = THREE.MathUtils.lerp(...hueRange, amount);

  ...
</code></pre>
<p>и с этим мы должны быть в состоянии показать 4 набора данных. Наведите указатель мыши на ярлыки или коснитесь их, чтобы переключать наборы </p>
<p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/threejs/resources/editor.html?url=/threejs/lessons/..%2Fthreejs-lots-of-objects-multiple-data-sets.html"></iframe></div>
  <a class="threejs_center" href="/threejs/lessons/../threejs-lots-of-objects-multiple-data-sets.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

</p>
<p>Обратите внимание, что есть несколько странных точек данных, которые действительно выделяются. 
Интересно, что с ними? ??! В любом случае, как мы анимируем между этими 4 наборами данных. </p>
<p>Много идей. </p>
<ul>
<li><p>Просто исчезните между ними, используя <code class="notranslate" translate="no">Material.opacity</code> </p>
<p>Проблема с этим решением заключается в том, что кубы полностью перекрываются, 
что означает, что возникнут проблемы z-борьбы. Возможно, мы могли бы исправить это, 
изменив функцию глубины и используя смешивание. Вероятно, мы должны изучить это. </p>
</li>
</ul>
<ul>
<li><p>Увеличьте набор, который мы хотим видеть, и уменьшите другие наборы. </p>
<p>Поскольку все коробки имеют свое происхождение в центре планеты, если мы масштабируем их ниже 1,0, они погрузятся в планету. 
Сначала это звучит как хорошая идея, но проблема в том, что все поля низкой высоты исчезнут почти сразу и не будут заменены, 
пока новый набор данных не масштабируется до 1,0. 
Это делает переход не очень приятным. Мы могли бы исправить это с помощью необычного шейдера. </p>
</li>
<li><p>Используйте Morphtargets </p>
<p>Morphtargets - это способ, которым мы предоставляем несколько значений 
для каждой вершины в геометрии и морф или lerp (линейная интерполяция) 
между ними. Morphtargets чаще всего используются для лицевой анимации 3D персонажей, но это не единственное их использование. </p>
</li>
</ul>
<p>Давайте попробуем morphtargets. </p>
<p>Мы по-прежнему создадим геометрию для каждого набора данных, 
но затем мы извлечем атрибут позиции из каждого из них и будем использовать их как морфтинги. </p>
<p>Сначала давайте изменим <code class="notranslate" translate="no">addBoxes</code>, чтобы просто создать и вернуть объединенную геометрию. </p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">-function addBoxes(file, hueRange) {
+function makeBoxes(file, hueRange) {
  const {min, max, data} = file;
  const range = max - min;

  ...

-  const mergedGeometry = BufferGeometryUtils.mergeBufferGeometries(
-      geometries, false);
-  const material = new THREE.MeshBasicMaterial({
-    vertexColors: THREE.VertexColors,
-  });
-  const mesh = new THREE.Mesh(mergedGeometry, material);
-  scene.add(mesh);
-  return mesh;
+  return BufferGeometryUtils.mergeBufferGeometries(
+     geometries, false);
}
</code></pre>
<p>Здесь есть еще одна вещь, которую нам нужно сделать. Morphtargets требуются, чтобы у всех было точно одинаковое количество вершин.
Вершина # 123 в одной цели должна иметь соответствующую вершину # 123 во всех других целях. Но, поскольку сейчас 
разные наборы данных могут иметь некоторые точки данных без данных, поэтому для этой точки не будет сгенерировано ни одного блока, 
что означало бы отсутствие соответствующих вершин для другого набора. Итак, нам нужно проверить все наборы данных и либо всегда генерировать что-либо, если
в каком-либо наборе есть данные, либо ничего не генерировать, если в каком-либо наборе отсутствуют данные. Давайте сделаем последнее. </p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">+function dataMissingInAnySet(fileInfos, latNdx, lonNdx) {
+  for (const fileInfo of fileInfos) {
+    if (fileInfo.file.data[latNdx][lonNdx] === undefined) {
+      return true;
+    }
+  }
+  return false;
+}

-function makeBoxes(file, hueRange) {
+function makeBoxes(file, hueRange, fileInfos) {
  const {min, max, data} = file;
  const range = max - min;

  ...

  const geometries = [];
  data.forEach((row, latNdx) =&gt; {
    row.forEach((value, lonNdx) =&gt; {
+      if (dataMissingInAnySet(fileInfos, latNdx, lonNdx)) {
+        return;
+      }
      const amount = (value - min) / range;

  ...
</code></pre>
<p>Теперь мы изменим код, который вызывал <code class="notranslate" translate="no">addBoxes</code>, для использования <code class="notranslate" translate="no">makeBoxes</code> и установки morphtargets. </p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">+// make geometry for each data set
+const geometries = fileInfos.map((info) =&gt; {
+  return makeBoxes(info.file, info.hueRange, fileInfos);
+});
+
+// use the first geometry as the base
+// and add all the geometries as morphtargets
+const baseGeometry = geometries[0];
+baseGeometry.morphAttributes.position = geometries.map((geometry, ndx) =&gt; {
+  const attribute = geometry.getAttribute(&#39;position&#39;);
+  const name = `target${ndx}`;
+  attribute.name = name;
+  return attribute;
+});
+const material = new THREE.MeshBasicMaterial({
+  vertexColors: THREE.VertexColors,
+  morphTargets: true,
+});
+const mesh = new THREE.Mesh(baseGeometry, material);
+scene.add(mesh);

const uiElem = document.querySelector(&#39;#ui&#39;);
fileInfos.forEach((info) =&gt; {
-  const boxes = addBoxes(info.file, info.hueRange);
-  info.root = boxes;
  const div = document.createElement(&#39;div&#39;);
  info.elem = div;
  div.textContent = info.name;
  uiElem.appendChild(div);
  function show() {
    showFileInfo(fileInfos, info);
  }
  div.addEventListener(&#39;mouseover&#39;, show);
  div.addEventListener(&#39;touchstart&#39;, show);
});
// show the first set of data
showFileInfo(fileInfos, fileInfos[0]);
</code></pre>
<p>Выше мы создаем геометрию для каждого набора данных, 
используем первый в качестве базы, затем получаем атрибут 
позиции из каждой геометрии и добавляем его в качестве морфтинга к базовой геометрии для позиции. </p>
<p>Теперь нам нужно изменить способ отображения и скрытия различных наборов данных. 
Вместо того, чтобы показывать или скрывать меш, нам нужно изменить влияние морфтинга. Для набора данных, 
который мы хотим видеть, нам нужно иметь влияние 1, а для всех тех, которые мы не хотим видеть, нам нужно иметь влияние 0. </p>
<p>Мы могли бы просто установить их в 0 или 1 напрямую, но если бы мы это сделали, мы бы не увидели никакой анимации,
она просто щелкала бы, что не отличалось бы от того, что у нас уже есть. Мы также могли бы написать некоторый пользовательский анимационный код, который был бы легок, 
но поскольку оригинальный глобус webgl использует
<a href="https://github.com/tweenjs/tween.js/">библиотеку анимации</a> давайте используем тот же самый здесь.</p>
<p>Нам нужно включить библиотеку </p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">import * as THREE from &#39;./resources/three/r122/build/three.module.js&#39;;
import {BufferGeometryUtils} from &#39;./resources/threejs/r122/examples/jsm/utils/BufferGeometryUtils.js&#39;;
import {OrbitControls} from &#39;./resources/threejs/r122/examples/jsm/controls/OrbitControls.js&#39;;
+import {TWEEN} from &#39;./resources/threejs/r122/examples/jsm/libs/tween.min.js&#39;;
</code></pre>
<p>А затем создайте <code class="notranslate" translate="no">Tween</code> чтобы оживить влияние.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// show the selected data, hide the rest
function showFileInfo(fileInfos, fileInfo) {
  fileInfos.forEach((info) =&gt; {
    const visible = fileInfo === info;
-    info.root.visible = visible;
    info.elem.className = visible ? &#39;selected&#39; : &#39;&#39;;
+    const targets = {};
+    fileInfos.forEach((info, i) =&gt; {
+      targets[i] = info === fileInfo ? 1 : 0;
+    });
+    const durationInMs = 1000;
+    new TWEEN.Tween(mesh.morphTargetInfluences)
+      .to(targets, durationInMs)
+      .start();
  });
  requestRenderIfNotRequested();
}
</code></pre>
<p>Мы также предполагаем вызывать TWEEN.update каждый кадр в нашем цикле рендеринга, но это указывает на проблему. 
&quot;tween.js&quot; предназначен для непрерывного рендеринга, но мы делаем <a href="threejs-rendering-on-demand.html">рендеринг по требованию </a>. 
Мы могли бы переключиться на непрерывный рендеринг, но иногда приятно рендерить только по требованию, так как он перестает использовать 
силу пользователя, когда ничего не происходит, поэтому давайте посмотрим, сможем ли мы сделать его анимированным по запросу. </p>
<p>Мы сделаем <code class="notranslate" translate="no">TweenManager</code>, чтобы помочь. Мы будем использовать его для создания 
<code class="notranslate" translate="no">Tweens</code> и отслеживания их. Он будет иметь метод <code class="notranslate" translate="no">update</code>, который будет 
возвращать true, если нам нужно будет вызвать его снова, и false, если все анимации завершены. </p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">class TweenManger {
  constructor() {
    this.numTweensRunning = 0;
  }
  _handleComplete() {
    --this.numTweensRunning;
    console.assert(this.numTweensRunning &gt;= 0);
  }
  createTween(targetObject) {
    const self = this;
    ++this.numTweensRunning;
    let userCompleteFn = () =&gt; {};
    // create a new tween and install our own onComplete callback
    const tween = new TWEEN.Tween(targetObject).onComplete(function(...args) {
      self._handleComplete();
      userCompleteFn.call(this, ...args);
    });
    // replace the tween&#39;s onComplete function with our own
    // so we can call the user&#39;s callback if they supply one.
    tween.onComplete = (fn) =&gt; {
      userCompleteFn = fn;
      return tween;
    };
    return tween;
  }
  update() {
    TWEEN.update();
    return this.numTweensRunning &gt; 0;
  }
}
</code></pre>
<p>Чтобы использовать его, мы создадим один </p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function main() {
  const canvas = document.querySelector(&#39;#c&#39;);
  const renderer = new THREE.WebGLRenderer({canvas});
+  const tweenManager = new TweenManger();

  ...
</code></pre>
<p>Мы будем использовать его для создания наших <code class="notranslate" translate="no">Tween</code>s.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// show the selected data, hide the rest
function showFileInfo(fileInfos, fileInfo) {
  fileInfos.forEach((info) =&gt; {
    const visible = fileInfo === info;
    info.elem.className = visible ? &#39;selected&#39; : &#39;&#39;;
    const targets = {};
    fileInfos.forEach((info, i) =&gt; {
      targets[i] = info === fileInfo ? 1 : 0;
    });
    const durationInMs = 1000;
-    new TWEEN.Tween(mesh.morphTargetInfluences)
+    tweenManager.createTween(mesh.morphTargetInfluences)
      .to(targets, durationInMs)
      .start();
  });
  requestRenderIfNotRequested();
}
</code></pre>
<p>Затем мы обновим наш цикл рендеринга, чтобы обновить анимацию и продолжать рендеринг, если анимация все еще выполняется. </p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function render() {
  renderRequested = false;

  if (resizeRendererToDisplaySize(renderer)) {
    const canvas = renderer.domElement;
    camera.aspect = canvas.clientWidth / canvas.clientHeight;
    camera.updateProjectionMatrix();
  }

+  if (tweenManager.update()) {
+    requestRenderIfNotRequested();
+  }

  controls.update();
  renderer.render(scene, camera);
}
render();
</code></pre>
<p>И с этим мы должны анимировать между наборами данных. </p>
<p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/threejs/resources/editor.html?url=/threejs/lessons/..%2Fthreejs-lots-of-objects-morphtargets.html"></iframe></div>
  <a class="threejs_center" href="/threejs/lessons/../threejs-lots-of-objects-morphtargets.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

</p>
<p>Кажется, это работает, но, к сожалению, мы потеряли цвета. </p>
<p>Three.js не поддерживает цвета morphtarget, и на самом деле это проблема оригинального <a href="https://github.com/dataarts/webgl-globe">шара webgl</a>.
В основном это просто делает цвета для первого набора данных. Любые другие наборы данных используют те же цвета, даже если они сильно различаются. </p>
<p>Давайте посмотрим, сможем ли мы добавить поддержку для изменения цвета.
Это может быть хрупким. Наименее хрупким способом, вероятно, было бы на 100% 
писать наши собственные шейдеры, но я думаю, что было бы полезно посмотреть, 
как модифицировать встроенные шейдеры. </p>
<p>Первое, что нам нужно сделать, это сделать цвет выделения кода <code class="notranslate" translate="no">BufferAttribute</code> из геометрии каждого набора данных. </p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// use the first geometry as the base
// and add all the geometries as morphtargets
const baseGeometry = geometries[0];
baseGeometry.morphAttributes.position = geometries.map((geometry, ndx) =&gt; {
  const attribute = geometry.getAttribute(&#39;position&#39;);
  const name = `target${ndx}`;
  attribute.name = name;
  return attribute;
});
+const colorAttributes = geometries.map((geometry, ndx) =&gt; {
+  const attribute = geometry.getAttribute(&#39;color&#39;);
+  const name = `morphColor${ndx}`;
+  attribute.name = `color${ndx}`;  // just for debugging
+  return {name, attribute};
+});
const material = new THREE.MeshBasicMaterial({
  vertexColors: THREE.VertexColors,
  morphTargets: true,
});
</code></pre>
<p>Затем нам нужно изменить шейдер three.js. Материалы Three.js имеют свойство <code class="notranslate" translate="no">Material.onBeforeCompile</code>, 
которое мы можем назначить функции. Это дает нам возможность изменить шейдер материала до его передачи в WebGL. 
На самом деле предоставленный шейдер - это на самом деле специальный синтаксис с тремя шейдерами,
который содержит только три блока шейдеров, которые три.js заменит реальным кодом GLSL для каждого блока. 
Вот как выглядит код неизмененного вершинного шейдера, передаваемый в <code class="notranslate" translate="no">onBeforeCompile</code>. </p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">#include &lt;common&gt;
#include &lt;uv_pars_vertex&gt;
#include &lt;uv2_pars_vertex&gt;
#include &lt;envmap_pars_vertex&gt;
#include &lt;color_pars_vertex&gt;
#include &lt;fog_pars_vertex&gt;
#include &lt;morphtarget_pars_vertex&gt;
#include &lt;skinning_pars_vertex&gt;
#include &lt;logdepthbuf_pars_vertex&gt;
#include &lt;clipping_planes_pars_vertex&gt;
void main() {
    #include &lt;uv_vertex&gt;
    #include &lt;uv2_vertex&gt;
    #include &lt;color_vertex&gt;
    #include &lt;skinbase_vertex&gt;
    #ifdef USE_ENVMAP
    #include &lt;beginnormal_vertex&gt;
    #include &lt;morphnormal_vertex&gt;
    #include &lt;skinnormal_vertex&gt;
    #include &lt;defaultnormal_vertex&gt;
    #endif
    #include &lt;begin_vertex&gt;
    #include &lt;morphtarget_vertex&gt;
    #include &lt;skinning_vertex&gt;
    #include &lt;project_vertex&gt;
    #include &lt;logdepthbuf_vertex&gt;
    #include &lt;worldpos_vertex&gt;
    #include &lt;clipping_planes_vertex&gt;
    #include &lt;envmap_vertex&gt;
    #include &lt;fog_vertex&gt;
}
</code></pre>
<p>Перебирая различные фрагменты, мы хотим заменить 
<a href="https://github.com/mrdoob/three.js/blob/dev/src/renderers/shaders/ShaderChunk/morphtarget_pars_vertex.glsl.js"><code class="notranslate" translate="no">morphtarget_pars_vertex</code> блок</a>
<a href="https://github.com/mrdoob/three.js/blob/dev/src/renderers/shaders/ShaderChunk/morphnormal_vertex.glsl.js"><code class="notranslate" translate="no">morphnormal_vertex</code> блок</a>
<a href="https://github.com/mrdoob/three.js/blob/dev/src/renderers/shaders/ShaderChunk/morphtarget_vertex.glsl.js"><code class="notranslate" translate="no">morphtarget_vertex</code> блок</a>
<a href="https://github.com/mrdoob/three.js/blob/dev/src/renderers/shaders/ShaderChunk/color_pars_vertex.glsl.js"><code class="notranslate" translate="no">color_pars_vertex</code> блок</a>
и <a href="https://github.com/mrdoob/three.js/blob/dev/src/renderers/shaders/ShaderChunk/color_vertex.glsl.js"><code class="notranslate" translate="no">color_vertex</code> блок</a></p>
<p>Для этого мы сделаем простой массив замен и применим их в <code class="notranslate" translate="no">Material.onBeforeCompile</code>. </p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const material = new THREE.MeshBasicMaterial({
  vertexColors: THREE.VertexColors,
  morphTargets: true,
});
+const vertexShaderReplacements = [
+  {
+    from: &#39;#include &lt;morphtarget_pars_vertex&gt;&#39;,
+    to: `
+      uniform float morphTargetInfluences[8];
+    `,
+  },
+  {
+    from: &#39;#include &lt;morphnormal_vertex&gt;&#39;,
+    to: `
+    `,
+  },
+  {
+    from: &#39;#include &lt;morphtarget_vertex&gt;&#39;,
+    to: `
+      transformed += (morphTarget0 - position) * morphTargetInfluences[0];
+      transformed += (morphTarget1 - position) * morphTargetInfluences[1];
+      transformed += (morphTarget2 - position) * morphTargetInfluences[2];
+      transformed += (morphTarget3 - position) * morphTargetInfluences[3];
+    `,
+  },
+  {
+    from: &#39;#include &lt;color_pars_vertex&gt;&#39;,
+    to: `
+      varying vec3 vColor;
+      attribute vec3 morphColor0;
+      attribute vec3 morphColor1;
+      attribute vec3 morphColor2;
+      attribute vec3 morphColor3;
+    `,
+  },
+  {
+    from: &#39;#include &lt;color_vertex&gt;&#39;,
+    to: `
+      vColor.xyz = morphColor0 * morphTargetInfluences[0] +
+                   morphColor1 * morphTargetInfluences[1] +
+                   morphColor2 * morphTargetInfluences[2] +
+                   morphColor3 * morphTargetInfluences[3];
+    `,
+  },
+];
+material.onBeforeCompile = (shader) =&gt; {
+  vertexShaderReplacements.forEach((rep) =&gt; {
+    shader.vertexShader = shader.vertexShader.replace(rep.from, rep.to);
+  });
+};
</code></pre>
<p>Three.js также сортирует <code class="notranslate" translate="no">morphtargets</code> и применяет только самые высокие влияния. 
Это позволяет разрешить гораздо больше целей морфинга, если одновременно используется только несколько.
Нам нужно выяснить, как он сортировал морф-цели, а затем установить соответствие наших цветовых атрибутов.
Мы можем сделать это, сначала удалив все наши цветовые атрибуты, а затем проверив атрибуты <code class="notranslate" translate="no">morphTarget</code> и увидев,
какой <code class="notranslate" translate="no">BufferAttribute</code> был назначен. Используя имя <code class="notranslate" translate="no">BufferAttribute</code>, мы можем сказать, какой соответствующий атрибут цвета необходим. </p>
<p>Сначала мы изменим имена атрибутов морфтаргет <code class="notranslate" translate="no">BufferAttributes</code>, чтобы их было легче разобрать позже. </p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// use the first geometry as the base
// and add all the geometries as morphtargets
const baseGeometry = geometries[0];
baseGeometry.morphAttributes.position = geometries.map((geometry, ndx) =&gt; {
  const attribute = geometry.getAttribute(&#39;position&#39;);
-  const name = `target${ndx}`;
+  // put the number in front so we can more easily parse it later
+  const name = `${ndx}target`;
  attribute.name = name;
  return attribute;
});
</code></pre>
<p>Затем мы можем установить соответствующие атрибуты цвета в <code class="notranslate" translate="no">Object3D.onBeforeRender</code>, 
который является свойством нашей сетки. Three.js вызовет его непосредственно перед рендерингом, 
что даст нам возможность исправить ситуацию. </p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const mesh = new THREE.Mesh(baseGeometry, material);
scene.add(mesh);
+mesh.onBeforeRender = function(renderer, scene, camera, geometry) {
+  // remove all the color attributes
+  for (const {name} of colorAttributes) {
+    geometry.deleteAttribute(name);
+  }
+
+  for (let i = 0; i &lt; colorAttributes.length; ++i) {
+    const attrib = geometry.getAttribute(`morphTarget${i}`);
+    if (!attrib) {
+      break;
+    }
+    // The name will be something like &quot;2target&quot; as we named it above
+    // where 2 is the index of the data set
+    const ndx = parseInt(attrib.name);
+    const name = `morphColor${i}`;
+    geometry.setAttribute(name, colorAttributes[ndx].attribute);
+  }
+};
</code></pre>
<p>И с этим у нас должны быть оживляющие цвета так же как коробки. </p>
<p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/threejs/resources/editor.html?url=/threejs/lessons/..%2Fthreejs-lots-of-objects-morphtargets-w-colors.html"></iframe></div>
  <a class="threejs_center" href="/threejs/lessons/../threejs-lots-of-objects-morphtargets-w-colors.html" target="_blank">нажмите здесь, чтобы открыть в отдельном окне</a>
</div>

</p>
<p>Я надеюсь, что пройти через это было полезно. Использование morphtargets либо через сервисы,
которые предоставляет three.js, либо путем написания пользовательских шейдеров - 
это распространенная техника для перемещения большого количества объектов. 
В качестве примера мы могли бы дать каждому кубу случайное место в другой цели и 
превратить его в свои первые позиции на земном шаре. Это может быть крутой способ представить миру. </p>
<p>Далее вас может заинтересовать добавление ярлыков к глобусу, который описан в разделе. 
 <a href="threejs-align-html-elements-to-3d.html"> «Выравнивание элементов HTML в 3D»</a>.</p>
<p>Примечание: мы могли бы попытаться просто изобразить процент мужчин
или женщин или общую разницу, но основываясь на том, как мы отображаем 
информацию, кубы, которые растут с поверхности земли, мы бы предпочли, 
чтобы большинство кубов были низкими. Если бы мы использовали одно из 
этих других сравнений, то большинство кубов имели бы примерно половину
их максимальной высоты, что не давало бы хорошей визуализации. 
Не стесняйтесь изменить количество GreaterThan
с Math.max (a - b, 0) на что-то вроде (a - b) «сырой разницы» или a / (a ​​+ b) «процентов», и вы поймете, что я имею в виду. </p>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/threejs/lessons/threejs-optimize-lots-of-objects-animated.html" >English</a>
    <option value="/threejs/lessons/fr/threejs-optimize-lots-of-objects-animated.html" >Français</a>
    <option value="/threejs/lessons/ja/threejs-optimize-lots-of-objects-animated.html" >日本語</a>
    <option value="/threejs/lessons/kr/threejs-optimize-lots-of-objects-animated.html" >한국어</a>
    <option value="/threejs/lessons/ru/threejs-optimize-lots-of-objects-animated.html" selected>Русский</a>
    <option value="/threejs/lessons/zh_cn/threejs-optimize-lots-of-objects-animated.html" >中文</a>
</select>


        <div id="toc">
          <ul>  <li>Введение</li>
        <ul>
          <li><a href="/threejs/lessons/ru/threejs-fundamentals.html">Базовые принципы</a></li>
<li><a href="/threejs/lessons/ru/threejs-responsive.html">Адаптивный дизайн</a></li>
<li><a href="/threejs/lessons/ru/threejs-prerequisites.html">Необходимые условия</a></li>
<li><a href="/threejs/lessons/ru/threejs-setup.html">Настройка</a></li>
        </ul>
  <li>Фунаментальные понятия</li>
        <ul>
          <li><a href="/threejs/lessons/ru/threejs-primitives.html">Примитивы</a></li>
<li><a href="/threejs/lessons/ru/threejs-scenegraph.html">Граф сцены</a></li>
<li><a href="/threejs/lessons/ru/threejs-materials.html">Материалы</a></li>
<li><a href="/threejs/lessons/ru/threejs-textures.html">Текстуры</a></li>
<li><a href="/threejs/lessons/ru/threejs-lights.html">Освещение</a></li>
<li><a href="/threejs/lessons/ru/threejs-cameras.html">Камера</a></li>
<li><a href="/threejs/lessons/ru/threejs-shadows.html">Тени</a></li>
<li><a href="/threejs/lessons/ru/threejs-fog.html">Туман</a></li>
<li><a href="/threejs/lessons/ru/threejs-rendertargets.html">Цели рендеринга</a></li>
<li><a href="/threejs/lessons/ru/threejs-custom-geometry.html">Пользовательская Geometry</a></li>
<li><a href="/threejs/lessons/ru/threejs-custom-buffergeometry.html">Пользовательская BufferGeometry</a></li>
        </ul>
  <li>Советы</li>
        <ul>
          <li><a href="/threejs/lessons/ru/threejs-rendering-on-demand.html">Рендеринг по требованию</a></li>
<li><a href="/threejs/lessons/ru/threejs-debugging-javascript.html">Отладка JavaScript</a></li>
<li><a href="/threejs/lessons/ru/threejs-debugging-glsl.html">Отладка GLSL</a></li>
<li><a href="/threejs/lessons/ru/threejs-tips.html#screenshot">Делаем скриншот холста</a></li>
<li><a href="/threejs/lessons/ru/threejs-tips.html#preservedrawingbuffer">Предотвращение очистки холста </a></li>
<li><a href="/threejs/lessons/ru/threejs-tips.html#tabindex">Ввод с клавиатуры</a></li>
<li><a href="/threejs/lessons/ru/threejs-tips.html#transparent-canvas">Делаем холст прозрачным </a></li>
<li><a href="/threejs/lessons/ru/threejs-tips.html#html-background">Создание анимированного фона в three.js </a></li>
        </ul>
  <li>Оптимизация</li>
        <ul>
          <li><a href="/threejs/lessons/ru/threejs-optimize-lots-of-objects.html">Оптимизация большого количества объектов</a></li>
<li><a href="/threejs/lessons/ru/threejs-optimize-lots-of-objects-animated.html">Оптимизация множества анимированных объектов</a></li>
<li><a href="/threejs/lessons/ru/threejs-offscreencanvas.html">Использование OffscreenCanvas в воркере</a></li>
        </ul>
  <li>Решения</li>
        <ul>
          <li><a href="/threejs/lessons/ru/threejs-load-obj.html">Load an .OBJ file</a></li>
<li><a href="/threejs/lessons/ru/threejs-load-gltf.html">Load a .GLTF file</a></li>
<li><a href="/threejs/lessons/ru/threejs-backgrounds.html">Add a Background or Skybox</a></li>
<li><a href="/threejs/lessons/ru/threejs-transparency.html">How to Draw Transparent Objects</a></li>
<li><a href="/threejs/lessons/ru/threejs-multiple-scenes.html">Несколько холстов, несколько сцен</a></li>
<li><a href="/threejs/lessons/ru/threejs-picking.html">Picking Objects with the mouse</a></li>
<li><a href="/threejs/lessons/ru/threejs-post-processing.html">Post Processing</a></li>
<li><a href="/threejs/lessons/ru/threejs-post-processing-3dlut.html">Applying a LUT File for effects</a></li>
<li><a href="/threejs/lessons/ru/threejs-shadertoy.html">Using Shadertoy shaders</a></li>
<li><a href="/threejs/lessons/ru/threejs-align-html-elements-to-3d.html">Aligning HTML Elements to 3D</a></li>
<li><a href="/threejs/lessons/ru/threejs-indexed-textures.html">Using Indexed Textures for Picking and Color</a></li>
<li><a href="/threejs/lessons/ru/threejs-canvas-textures.html">Using A Canvas for Dynamic Textures</a></li>
<li><a href="/threejs/lessons/ru/threejs-billboards.html">Billboards and Facades</a></li>
<li><a href="/threejs/lessons/ru/threejs-cleanup.html">Freeing Resources</a></li>
<li><a href="/threejs/lessons/ru/threejs-voxel-geometry.html">Making Voxel Geometry (Minecraft)</a></li>
<li><a href="/threejs/lessons/ru/threejs-game.html">Start making a Game.</a></li>
        </ul>
  <li>WebVR</li>
        <ul>
          <li><a href="/threejs/lessons/ru/threejs-webvr.html">VR - Basics</a></li>
<li><a href="/threejs/lessons/ru/threejs-webvr-look-to-select.html">VR - Look To Select</a></li>
<li><a href="/threejs/lessons/ru/threejs-webvr-point-to-select.html">VR - Point To Select</a></li>
        </ul>
  <li>Ссылки</li>
        <ul>
          <li><a href="/threejs/lessons/ru/threejs-material-table.html">Таблица материалов</a></li>
        </ul></ul>
<ul>
  <li><a href="https://github.com/gfxfundamentals/threejsfundamentals">github</a></li>
  <li><a href="https://threejs.org">three.js</a></li>
  <li><a href="https://threejs.org/docs/">three.js docs</a></li>
</ul>

        </div>
    </div>
    <div class="lesson-comments">
        <div>Вопросы? <a href="http://stackoverflow.com/questions/tagged/three.js">Спросите на stackoverflow</a>.</div>
        <div>Нашли ошибку? <a href="http://github.com/gfxfundamentals/threejsfundamentals/issues">Создайте issue на github</a>.</div>

        <div id="disqus_thread"></div>
        <script type="text/javascript">
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'threejsfundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'Three.js Оптимизация большого количества анимированных объектов';
            var disqus_title = 'Three.js Оптимизация большого количества анимированных объектов';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("threejsfundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script src="/3rdparty/jquery-3.3.1.slim.min.js"></script>
<script src="/threejs/lessons/resources/prettify.js"></script>
<script src="/threejs/lessons/resources/lesson.js"></script>
<script>
(function() {
  if (window.location.hostname.indexOf("threejsfundamentals.org") < 0) {
      return;
  }

  function addScript(src, fn) {
    const script = document.createElement('script');
    const firstScript = document.getElementsByTagName('script')[0];
    script.async = true;
    script.defer = true;
    if (fn) {
      script.addEventListener('load', fn);
    }
    script.src = src;
    firstScript.parentNode.insertBefore(script, firstScript);
  }

  addScript('//cdn.webglstats.com/stat.js');
  addScript('https://www.googletagmanager.com/gtag/js?id=UA-120733518-1', () => {
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-120733518-1');
  });
}());
</script>


</html>



