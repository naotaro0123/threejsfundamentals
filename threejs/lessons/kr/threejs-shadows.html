<!DOCTYPE html>
<!-- this file is auto-generated from threejs/lessons/kr/threejs-shadows.md. Do not edited directly -->
<!--
Copyright 2018, Google Inc.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of Google Inc. nor the names of their
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="ko">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Three.js의 그림자에 대해 알아봅니다">
<meta name="keywords" content="webgl graphics three.js">
<meta name="thumbnail" content="https://threejsfundamentals.org/threejs/lessons/screenshots/threejs-shadows_ko.jpg">

<meta property="og:title" content="Three.js 그림자">
<meta property="og:type" content="website">
<meta property="og:image" content="https://threejsfundamentals.org/threejs/lessons/screenshots/threejs-shadows_ko.jpg">
<meta property="og:description" content="Three.js의 그림자에 대해 알아봅니다">
<meta property="og:url" content="https://threejsfundamentals.org/threejs/lessons/kr/threejs-shadows.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="threejsfundamentals.org">
<meta name="twitter:title" content="Three.js 그림자">
<meta name="twitter:url" content="https://threejsfundamentals.org/threejs/lessons/kr/threejs-shadows.html">
<meta name="twitter:description" content="Three.js의 그림자에 대해 알아봅니다">
<meta name="twitter:image:src" content="https://threejsfundamentals.org/threejs/lessons/screenshots/threejs-shadows_ko.jpg">

  <link rel="alternate" hreflang="en" href="https://webglfundamentals.org/threejs/lessons/threejs-shadows.html">
  <link rel="alternate" hreflang="fr" href="https://webglfundamentals.org/threejs/lessons/fr/threejs-shadows.html">
  <link rel="alternate" hreflang="ja" href="https://webglfundamentals.org/threejs/lessons/ja/threejs-shadows.html">
  <link rel="alternate" hreflang="kr" href="https://webglfundamentals.org/threejs/lessons/kr/threejs-shadows.html">
  <link rel="alternate" hreflang="ru" href="https://webglfundamentals.org/threejs/lessons/ru/threejs-shadows.html">
  <link rel="alternate" hreflang="zh_cn" href="https://webglfundamentals.org/threejs/lessons/zh_cn/threejs-shadows.html">




<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://threejsfundamentals.org/#website",
      "url":"https://threejsfundamentals.org/",
      "name":"ThreejsFundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://threejsfundamentals.org/threejs/lessons/kr/threejs-shadows.html#primaryimage",
      "url":"https://threejsfundamentals.org/threejs/lessons/screenshots/threejs-shadows_ko.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://threejsfundamentals.org/threejs/lessons/kr/threejs-shadows.html#webpage",
      "url":"https://threejsfundamentals.org/threejs/lessons/kr/threejs-shadows.html",
      "inLanguage":"ko",
      "name":"Three.js 그림자",
      "keywords":"webgl graphics three.js programming",
      "isPartOf":{
        "@id":"https://threejsfundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://threejsfundamentals.org/threejs/lessons/kr/threejs-shadows.html#primaryimage"
      }
    }
  ]
}
</script>

<title>Three.js 그림자</title>
<link href="/threejs/lessons/resources/threejsfundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="apple-touch-icon" href="/threejs/lessons/resources/threejsfundamentals-icon.png">
<link rel="icon" href="/threejs/lessons/resources/threejsfundamentals-icon.png">

<link rel="stylesheet" href="/threejs/lessons/lang.css">
<link rel="stylesheet" href="/threejs/lessons/kr/lang.css">
<link rel="stylesheet" href="/threejs/lessons/resources/lesson.css">
</head>
<body>
<div class="threejs_navbar">
  <div>
    <select class="language">
    <option value="/threejs/lessons/threejs-shadows.html" >English</a>
    <option value="/threejs/lessons/fr/threejs-shadows.html" >Français</a>
    <option value="/threejs/lessons/ja/threejs-shadows.html" >日本語</a>
    <option value="/threejs/lessons/kr/threejs-shadows.html" selected>한국어</a>
    <option value="/threejs/lessons/ru/threejs-shadows.html" >Русский</a>
    <option value="/threejs/lessons/zh_cn/threejs-shadows.html" >中文</a>
</select>


    <a href="#toc">목차</a>
  </div>
</div>
<div class="threejs_header">
  <h1><a href="/threejs/lessons/kr/">threejsfundamentals.org</a></h1>
<style>
#forkongithub a {
    background: #000;
    color: #fff;
    text-decoration: none;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 2rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 300px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(150px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a:hover {
    background: #c11;
    color: #fff;
}
#forkongithub a::before,#forkongithub a::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub a::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
@media (max-width: 900px) {
    #forkongithub a{
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub a{
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub"><a href="https://github.com/gfxfundamentals/threejsfundamentals">Fix, Fork, Contribute <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"/>
    </g>
</svg>
</a></div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>Three.js 그림자</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>※ 이 글은 Three.js의 튜토리얼 시리즈로서,
먼저 <a href="threejs-fundamentals.html">Three.js의 기본 구조에 관한 글</a>을
읽고 오길 권장합니다.</p>
<p>※ 이전 글인 <a href="threejs-cameras.html">카메라에 관한 글</a>과
<a href="threejs-lights.html">조명에 관한 글</a>에서 이 장을 읽는 꼭 필요한 내용을
다루었으니 꼭 먼저 읽고 오시기 바랍니다.</p>
<p>3D 그래픽에서 그림자란 그리 간단한 주제가 아닙니다. 그림자를 구현하는 방법은
아주 많지만 모두 단점이 있기에 어떤 것이 가장 효율적이라고 말하기 어렵습니다.
이는 Three.js에서 제공하는 방법도 마찬가지이죠.</p>
<p>Three.js는 기본적으로 <em>그림자 맵(shadow maps)</em>을 사용합니다. 그림자 맵이란
<em>그림자를 만드는 빛의 영향을 받는, 그림자를 드리우는 모든 물체를 빛의 시점에서
렌더링</em>하는 기법을 말합니다. 중요하니 <strong>한 번 더 읽어보세요!</strong></p>
<p>다시 말해, 공간 안에 20개의 물체와 5개의 조명이 있고, 20개의 물체 모두
그림자를 드리우며 5개의 조명 모두 그림자를 지게 한다면, 한 장면을 만들기
위해 총 6번 화면을 렌더링할 것이라는 이야기입니다. 먼저 조명 1번에 대해
20개의 물체를 전부 렌더링하고, 다음에는 2번 조명, 그 다음에는 3번...
이렇게 처음 5번 렌더링한 결과물을 합쳐 최종 결과물을 만드는 것이죠.</p>
<p>만약 여기에 포인트(point) 조명을 하나 추가하면 조명 하나 때문에 6번을 다시
렌더링해야 합니다.</p>
<p>이 때문에 그림자를 지게 하는 조명을 여러개 만들기보다 다른 방법을 찾는
경우가 보통입니다. 주로 사용하는 방법은 조명이 여러개 있어도 하나의 조명만
그림자를 지게끔 설정하는 것이죠.</p>
<p>물론 라이트맵(lightmaps)이나 앰비언트 오클루전(ambient occlusion)을 이용해
빛의 영향을 미리 계산할 수도 있습니다. 이러면 정적 조명이나 정적 빛 반사를
사용하는 것이기에 수정하기가 어렵지만, 적어도 성능은 빠릅니다. 이 두 가지
모두 나중에 별도로 다룰 것입니다.</p>
<p>가짜 그림자를 사용하는 방법도 있습니다. 평면을 만들고, 흑백 텍스처를 입혀
땅 위에 그림자가 있을 만한 위치에 가져다 놓는 것이죠.</p>
<p>예를 들어 아래 텍스처를 사용해 가짜 그림자를 만들어보겠습니다.</p>
<div class="threejs_center"><img src="../../resources/images/roundshadow.png"></div>

<p><a href="threejs-cameras.html">이전 글</a>에서 작성했던 코드를 일부 활용하겠습니다.</p>
<p>먼저 배경을 흰색으로 칠합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const scene = new THREE.Scene();
+scene.background = new THREE.Color(&#39;white&#39;);
</code></pre>
<p>같은 체크판 무늬 땅을 사용하되, 땅이 조명의 영향을 받을 필요는 없으니
<code class="notranslate" translate="no">MeshBasicMaterial</code>을 사용하겠습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">+const loader = new THREE.TextureLoader();

{
  const planeSize = 40;

-  const loader = new THREE.TextureLoader();
  const texture = loader.load(&#39;resources/images/checker.png&#39;);
  texture.wrapS = THREE.RepeatWrapping;
  texture.wrapT = THREE.RepeatWrapping;
  texture.magFilter = THREE.NearestFilter;
  const repeats = planeSize / 2;
  texture.repeat.set(repeats, repeats);

  const planeGeo = new THREE.PlaneBufferGeometry(planeSize, planeSize);
  const planeMat = new THREE.MeshBasicMaterial({
    map: texture,
    side: THREE.DoubleSide,
  });
+  planeMat.color.setRGB(1.5, 1.5, 1.5);
  const mesh = new THREE.Mesh(planeGeo, planeMat);
  mesh.rotation.x = Math.PI * -.5;
  scene.add(mesh);
}
</code></pre>
<p>평면의 색상을 <code class="notranslate" translate="no">1.5, 1.5, 1.5</code>로 설정했습니다. 체크판 텍스처의 색상을 1.5, 1.5, 1.5 만큼
곱해준 것이죠. 체크판 원본 텍스처의 색상이 0x808080(회색), 0xC0C0C0(옅은 회색)이므로,
여기에 1.5를 곱해주면 흰색, 옅은 회색 체크판이 됩니다.</p>
<p>이제 그림자 텍스처를 로드해보죠.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const shadowTexture = loader.load(&#39;resources/images/roundshadow.png&#39;);
</code></pre>
<p>구체와 관련된 객체를 분류하기 위해 배열을 만들겠습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const sphereShadowBases = [];
</code></pre>
<p>다음으로 구체 geometry를 만듭니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const sphereRadius = 1;
const sphereWidthDivisions = 32;
const sphereHeightDivisions = 16;
const sphereGeo = new THREE.SphereBufferGeometry(sphereRadius, sphereWidthDivisions, sphereHeightDivisions);
</code></pre>
<p>가짜 그림자를 위한 평면 <code class="notranslate" translate="no">geometry</code>도 만듭니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const planeSize = 1;
const shadowGeo = new THREE.PlaneBufferGeometry(planeSize, planeSize);
</code></pre>
<p>이제 구체를 아주 많이 만들겠습니다. 각각 구체마다 <code class="notranslate" translate="no">컨테이너</code> 역할을 할
<code class="notranslate" translate="no">THREE.Object3D</code>를 만들고, 그림자 평면 mesh, 구체 mesh를 이
컨테이너의 자식으로 만듭니다. 이러면 구체와 그림자를 동시에 움직일 수
있죠. z-파이팅 현상을 막기 위해 그림자는 땅보다 약간 위에 둡니다.
또 <code class="notranslate" translate="no">depthWrite</code> 속성을 false로 설정해 그림자끼리 충돌하는 현상을
막습니다. 이 충돌 현상은 <a href="threejs-transparency.html">다른 글</a>에서
더 자세히 이야기할 거예요. 그림자는 빛을 반사하지 않으니 <code class="notranslate" translate="no">MeshBasicMaterial</code>을
사용합니다.</p>
<p>구체의 색상을 각각 다르게 지정하고, 컨테이너, 구체 mesh, 그림자 mesh와
구체의 처음 y축 좌표를 배열에 기록합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const numSpheres = 15;
for (let i = 0; i &lt; numSpheres; ++i) {
  // 구체와 그림자가 같이 움직이도록 컨테이너(base)를 만듭니다
  const base = new THREE.Object3D();
  scene.add(base);

  /**
   * 그림자를 컨테이너에 추가합니다
   * 주의: 여기서는 각 구체의 투명도를 따로 설정할 수 있도록
   * 재질을 각각 따로 만듬
   */
  const shadowMat = new THREE.MeshBasicMaterial({
    map: shadowTexture,
    transparent: true,    // 땅이 보이도록
    depthWrite: false,    // 그림자를 따로 정렬하지 않도록
  });
  const shadowMesh = new THREE.Mesh(shadowGeo, shadowMat);
  shadowMesh.position.y = 0.001;  // 그림자를 땅에서 살짝 위에 배치
  shadowMesh.rotation.x = Math.PI * -.5;
  const shadowSize = sphereRadius * 4;
  shadowMesh.scale.set(shadowSize, shadowSize, shadowSize);
  base.add(shadowMesh);

  // 구체를 컨테이너에 추가
  const u = i / numSpheres;   // 반복문이 진행됨에 따라 0에서 1사이 값을 지정
  const sphereMat = new THREE.MeshPhongMaterial();
  sphereMat.color.setHSL(u, 1, .75);
  const sphereMesh = new THREE.Mesh(sphereGeo, sphereMat);
  sphereMesh.position.set(0, sphereRadius + 2, 0);
  base.add(sphereMesh);

  // y축 좌표를 포함해 나머지 요소를 기록
  sphereShadowBases.push({ base, sphereMesh, shadowMesh, y: sphereMesh.position.y });
}
</code></pre>
<p>조명은 2개를 만들겠습니다. 하나는 <code class="notranslate" translate="no">HemisphereLight</code>, 강도를 2로 설정해 화면을 아주
밝게 설정할 겁니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">{
  const skyColor = 0xB1E1FF;  // 하늘색
  const groundColor = 0xB97A20;  // 오렌지 브라운
  const intensity = 2;
  const light = new THREE.HemisphereLight(skyColor, groundColor, intensity);
  scene.add(light);
}
</code></pre>
<p>다른 하나는 구체의 윤곽을 좀 더 분명하게 해 줄 <code class="notranslate" translate="no">DirectionalLight</code>입니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">{
  const color = 0xFFFFFF;
  const intensity = 1;
  const light = new THREE.DirectionalLight(color, intensity);
  light.position.set(0, 10, 5);
  light.target.position.set(-5, 0, 0);
  scene.add(light);
  scene.add(light.target);
}
</code></pre>
<p>이대로도 렌더링해도 좋지만, 구체들에 애니메이션을 한 번 줘봅시다.
컨테이너를 움직여 구체, 그림자가 xz축 평면을 따라 움직이게 하고,
<code class="notranslate" translate="no">Math.abs(Math.sin(time))</code>를 사용해 구체에 공처럼 통통 튀는
애니메이션을 넣어줍니다. 또 그림자 재질의 투명도를 조절해 구체가
높을수록 그림자가 옅어지도록 합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function render(time) {
  time *= 0.001;  // 초 단위로 변환

  ...

  sphereShadowBases.forEach((sphereShadowBase, ndx) =&gt; {
    const { base, sphereMesh, shadowMesh, y } = sphereShadowBase;

    // u는 구체의 반복문을 실행하면서 인덱스에 따라 0 이상, 1 이하로 지정됩니다
    const u = ndx / sphereShadowBases.length;

    /**
     * 컨테이너의 위치를 계산합니다. 구체와 그림자가
     * 컨테이너에 종속적이므로 위치가 같이 변합니다
     */
    const speed = time * .2;
    const angle = speed + u * Math.PI * 2 * (ndx % 1 ? 1 : -1);
    const radius = Math.sin(speed - ndx) * 10;
    base.position.set(Math.cos(angle) * radius, 0, Math.sin(angle) * radius);

    // yOff 값은 0 이상 1 이하입니다
    const yOff = Math.abs(Math.sin(time * 2 + ndx));
    // 구체를 위아래로 튕김
    sphereMesh.position.y = y + THREE.MathUtils.lerp(-2, 2, yOff);
    // 구체가 위로 올라갈수록 그림자가 옅어짐
    shadowMesh.material.opacity = THREE.MathUtils.lerp(1, .25, yOff);
  });

  ...
</code></pre>
<p>15가지 색상의 탱탱볼을 완성했습니다.</p>
<p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/threejs/resources/editor.html?url=/threejs/lessons/..%2Fthreejs-shadows-fake.html"></iframe></div>
  <a class="threejs_center" href="/threejs/lessons/../threejs-shadows-fake.html" target="_blank">새 탭에서 보기</a>
</div>

</p>
<p>물론 다른 모양의 그림자를 사용해야 하는 경우도 있습니다. 그림자의 경계를 분명하게
하고 싶을 수도 있죠. 하지만 모든 물체의 그림자를 둥글게 표현하는 것이 좋은 경우도
분명 있습니다. 모든 그림자를 둥글게 표현한 예 중 하나는 <a href="https://www.google.com/search?tbm=isch&amp;q=animal+crossing+pocket+camp+screenshots">동물의 숲 포켓 캠프</a>입니다.
자연스럽고 성능면에서도 이득이죠. <a href="https://www.google.com/search?q=monument+valley+screenshots&amp;tbm=isch">Monument Valley</a>도
메인 캐릭터에 이런 그림자를 사용한 것으로 보입니다.</p>
<p>이제 그림자 맵을 살펴보겠습니다. 그림자를 드리울 수 있는 조명은 3가지, <code class="notranslate" translate="no">DirectionalLight</code>,
<code class="notranslate" translate="no">PointLight</code>, <code class="notranslate" translate="no">SpotLight</code>입니다.</p>
<p><a href="threejs-lights.html">조명에 관한 글</a>에서 썼던 예제로 먼저 <code class="notranslate" translate="no">DirectionalLight</code>부터
살펴보죠.</p>
<p>먼저 renderer의 그림자 맵 옵션을 켜야 합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const renderer = new THREE.WebGLRenderer({canvas});
+renderer.shadowMap.enabled = true;
</code></pre>
<p>조명도 그림자를 드리우도록 옵션을 활성화합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const light = new THREE.DirectionalLight(color, intensity);
+light.castShadow = true;
</code></pre>
<p>또한 장면(scene) 안 각 mesh에 그림자를 드리울지, 그림자의 영향을 받을지 설정해줘야 합니다.</p>
<p>바닥 아래는 굳이 신경 쓸 필요가 없으니 평면(바닥)은 그림자의 영향만 받게 하겠습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const mesh = new THREE.Mesh(planeGeo, planeMat);
mesh.receiveShadow = true;
</code></pre>
<p>정육면체와 구체는 그림자도 드리우고, 영향도 받도록 설정합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const mesh = new THREE.Mesh(cubeGeo, cubeMat);
mesh.castShadow = true;
mesh.receiveShadow = true;

...

const mesh = new THREE.Mesh(sphereGeo, sphereMat);
mesh.castShadow = true;
mesh.receiveShadow = true;
</code></pre>
<p>이제 실행해보죠.</p>
<p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/threejs/resources/editor.html?url=/threejs/lessons/..%2Fthreejs-shadows-directional-light.html"></iframe></div>
  <a class="threejs_center" href="/threejs/lessons/../threejs-shadows-directional-light.html" target="_blank">새 탭에서 보기</a>
</div>

</p>
<p>이런, 그림자 일부가 잘려나간 것이 보이나요?</p>
<p>이는 빛의 시점에서 장면을 렌더링해 그림자 맵을 만들기 때문입니다. 위 예제를 예로 들면
<code class="notranslate" translate="no">DirectionalLight</code>의 위치에 카메라가 있고, 해당 조명의 목표를 바라보는 것이죠. 조명의
그림자에는 별도의 카메라가 있고, 이전에 <a href="threejs-cameras.html">카메라에 관한 글</a>에서
설명한 것처럼 일정 공간 안의 그림자만 렌더링합니다. 위 예제에서는 그 공간이 너무 좁은
것이죠.</p>
<p>그림자용 카메라를 시각화하기 위해 조명의 그림자 속성에서 카메라를 가져와 <code class="notranslate" translate="no">CameraHelper</code>를
생성한 뒤, 장면에 추가하겠습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const cameraHelper = new THREE.CameraHelper(light.shadow.camera);
scene.add(cameraHelper);
</code></pre>
<p>이제 그림자가 렌더링되는 공간을 확인할 수 있을 겁니다.</p>
<p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/threejs/resources/editor.html?url=/threejs/lessons/..%2Fthreejs-shadows-directional-light-with-camera-helper.html"></iframe></div>
  <a class="threejs_center" href="/threejs/lessons/../threejs-shadows-directional-light-with-camera-helper.html" target="_blank">새 탭에서 보기</a>
</div>

</p>
<p>target의 x 값을 조정해보면 그림자용 카메라 범위 안에 있는 곳에만 그림자가 보이는
것을 확인할 수 있을 겁니다.</p>
<p>이 공간의 크기는 이 카메라의 속성을 수정해 바꿀 수 있습니다.</p>
<p>그림자용 카메라의 속성을 수정하는 GUI를 추가해보죠. <code class="notranslate" translate="no">DirectionalLight</code>는 빛이 평행으로
나아가므로, <code class="notranslate" translate="no">DirectionalLight</code>는  그림자용 카메라로 <code class="notranslate" translate="no">OrthographicCamera</code>(정사영 카메라)를
사용합니다. <code class="notranslate" translate="no">OrthographicCamera</code>가 뭔지 잘 기억나지 않는다면, <a href="threejs-cameras.html">카메라에 관한 이전 글</a>을
참고하세요.</p>
<p><code class="notranslate" translate="no">OrthographicCamera</code>의 시야는 육면체나 <em>절두체(frustum)</em>로 정의한다고 했었죠. <code class="notranslate" translate="no">left</code>,
<code class="notranslate" translate="no">right</code>, <code class="notranslate" translate="no">top</code>, <code class="notranslate" translate="no">bottom</code>, <code class="notranslate" translate="no">near</code>, <code class="notranslate" translate="no">far</code>, <code class="notranslate" translate="no">zoom</code> 속성을 지정해서요.</p>
<p>dat.GUI가 쓸 간단한 헬퍼 클래스를 하나 더 만들겠습니다. 이 <code class="notranslate" translate="no">DimensionGUIHelper</code>는
객체와 속성 이름 2개를 인자로 받아, GUI가 하나의 값을 조정할 때 하나의 값은 양수로,
다른 값은 음수로 지정합니다. 이렇게 하면 <code class="notranslate" translate="no">left</code>와 <code class="notranslate" translate="no">right</code>값을 <code class="notranslate" translate="no">width</code>로, <code class="notranslate" translate="no">up</code>과
<code class="notranslate" translate="no">down</code>값을 <code class="notranslate" translate="no">height</code>로 바꾸어 조작할 수 있죠.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">class DimensionGUIHelper {
  constructor(obj, minProp, maxProp) {
    this.obj = obj;
    this.minProp = minProp;
    this.maxProp = maxProp;
  }
  get value() {
    return this.obj[this.maxProp] * 2;
  }
  set value(v) {
    this.obj[this.maxProp] = v /  2;
    this.obj[this.minProp] = v / -2;
  }
}
</code></pre>
<p>또한 <a href="threejs-cameras.html">이전 글</a>에서 썼던 <code class="notranslate" translate="no">MinMaxGUIHelper</code>를 가져와 <code class="notranslate" translate="no">near</code>와
<code class="notranslate" translate="no">far</code> 속성을 조작하는 데 사용하겠습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const gui = new GUI();
gui.addColor(new ColorGUIHelper(light, &#39;color&#39;), &#39;value&#39;).name(&#39;color&#39;);
gui.add(light, &#39;intensity&#39;, 0, 2, 0.01);
+{
+  const folder = gui.addFolder(&#39;Shadow Camera&#39;);
+  folder.open();
+  folder.add(new DimensionGUIHelper(light.shadow.camera, &#39;left&#39;, &#39;right&#39;), &#39;value&#39;, 1, 100)
+    .name(&#39;width&#39;)
+    .onChange(updateCamera);
+  folder.add(new DimensionGUIHelper(light.shadow.camera, &#39;bottom&#39;, &#39;top&#39;), &#39;value&#39;, 1, 100)
+    .name(&#39;height&#39;)
+    .onChange(updateCamera);
+  const minMaxGUIHelper = new MinMaxGUIHelper(light.shadow.camera, &#39;near&#39;, &#39;far&#39;, 0.1);
+  folder.add(minMaxGUIHelper, &#39;min&#39;, 0.1, 50, 0.1).name(&#39;near&#39;).onChange(updateCamera);
+  folder.add(minMaxGUIHelper, &#39;max&#39;, 0.1, 50, 0.1).name(&#39;far&#39;).onChange(updateCamera);
+  folder.add(light.shadow.camera, &#39;zoom&#39;, 0.01, 1.5, 0.01).onChange(updateCamera);
+}
</code></pre>
<p>그리고 값이 바뀔 때마다 <code class="notranslate" translate="no">updateCamera</code> 함수를 호출하도록 합니다. 이 함수 안에서는
조명, 조명 헬퍼, 조명의 그림자용 카메라, 그림자용 카메라의 헬퍼를 업데이트할 거예요.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function updateCamera() {
  // 헬퍼가 가이드라인을 그릴 때 필요한 조명 목표(target)의 matrixWorld를 업데이트 합니다
  light.target.updateMatrixWorld();
  helper.update();
  // 그림자용 카메라의 투영 행렬(projection matrix)를 업데이트합니다
  light.shadow.camera.updateProjectionMatrix();
  // 그림자용 카메라를 보기 위해 설치한 카메라의 헬퍼를 업데이트합니다
  cameraHelper.update();
}
updateCamera();
</code></pre>
<p>이제 그림자용 카메라에 GUI가 생겼으니, 값들을 조정하며 놀아봅시다.</p>
<p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/threejs/resources/editor.html?url=/threejs/lessons/..%2Fthreejs-shadows-directional-light-with-camera-gui.html"></iframe></div>
  <a class="threejs_center" href="/threejs/lessons/../threejs-shadows-directional-light-with-camera-gui.html" target="_blank">새 탭에서 보기</a>
</div>

</p>
<p><code class="notranslate" translate="no">width</code>와 <code class="notranslate" translate="no">height</code> 속성을 30 정도로 조정하면 그림자가 있어야 할만한 공간은
대부분 그림자용 카메라 안에 속할 겁니다.</p>
<p>하지만 여기서 의문이 하나 생깁니다. 어째서 <code class="notranslate" translate="no">width</code>와 <code class="notranslate" translate="no">height</code>를 완전 큰 값으로
설정해 모든 요소를 다 포함하도록 하지 않는 걸까요? <code class="notranslate" translate="no">width</code>와 <code class="notranslate" translate="no">height</code>를 100 정도로
설정해보세요. 아래와 같은 현상이 나타날 겁니다.</p>
<div class="threejs_center"><img src="../resources/images/low-res-shadow-map.png" style="width: 369px"></div>

<p>왜 그림자의 해상도가 낮아졌을까요?</p>
<p>이는 그림자 관련 설정을 할 때 항상 주의해야하는 부분입니다. 사실 그림자 맵은 그림자가
포함된 하나의 텍스처입니다. 이 텍스처는 크기가 정해져 있죠. 위 예제에서 카메라의 공간을
늘리면, 이 텍스처 또한 늘어납니다. 다시 말해 공간을 크게 설정할수록 그림자가 더 각져
보일 거라는 얘기죠.</p>
<p>그림자 맵의 해상도는 <code class="notranslate" translate="no">light.shadow.mapSize</code> 속성의 <code class="notranslate" translate="no">width</code>와 <code class="notranslate" translate="no">height</code> 속성으로 설정합니다(기본값은
512x512). 그림자 맵은 크게 설정할수록 메모리를 많이 차지하고, 연산이 더 복잡해지므로
가능한 작게 설정하는 것이 좋습니다. 이는 그림자용 카메라의 공간도 마찬가지죠. 작을 수록
그림자의 퀄리티가 좋아질 테니 가능한 공간을 작게 설정하는 것이 좋습니다. 또한 기기마다
렌더링할 수 있는 텍스처의 용량이 정해져 있으니 주의해야 합니다. Three.js에서 이 용량은
<a href="WebGLRenderer.capabilities"><code class="notranslate" translate="no">renderer.capabilities.maxTextureSize</code></a>로 확인할 수 있습니다.</p>
<p><code class="notranslate" translate="no">SpotLight</code>는 그림자용 카메라로 <code class="notranslate" translate="no">PerspectiveCamera</code>(원근 카메라)를 사용합니다. <code class="notranslate" translate="no">DirectionalLight</code>의
그림자용 카메라는 거의 모든 속성을 직접 변경할 수 있었지만, <code class="notranslate" translate="no">SpotLight</code>의 그림자용 카메라는
조명 속성의 영향을 받습니다. 카메라의 <code class="notranslate" translate="no">fov</code> 속성은 <code class="notranslate" translate="no">SpotLight</code>의 <code class="notranslate" translate="no">angle</code> 속성과 직접 연결되어
있죠. <code class="notranslate" translate="no">aspect</code>는 그림자 맵의 크기에 따라 자동으로 정해집니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">-const light = new THREE.DirectionalLight(color, intensity);
+const light = new THREE.SpotLight(color, intensity);
</code></pre>
<p>추가로 <a href="threejs-lights.html">이전 글</a>에서 썼던 <code class="notranslate" translate="no">penumbra(반음영)</code>, <code class="notranslate" translate="no">angle</code> 설정을 가져오겠습니다.</p>
<p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/threejs/resources/editor.html?url=/threejs/lessons/..%2Fthreejs-shadows-spot-light-with-camera-gui.html"></iframe></div>
  <a class="threejs_center" href="/threejs/lessons/../threejs-shadows-spot-light-with-camera-gui.html" target="_blank">새 탭에서 보기</a>
</div>

</p>
<p>마지막으로 <code class="notranslate" translate="no">PointLight</code>를 살펴보죠. <code class="notranslate" translate="no">PointLight</code>는 모든 방향으로 빛을 발산하기에
관련 설정은 <code class="notranslate" translate="no">near</code>와 <code class="notranslate" translate="no">far</code> 정도입니다. 그리고 사실 <code class="notranslate" translate="no">PointLight</code>의 그림자는 정육면체의
각 면에 <code class="notranslate" translate="no">SpotLight</code>를 하나씩, 총 6개의 그림자를 놓은 것과 같습니다. 한 방향에 한
번씩, 총 6번을 렌더링해야 하니 렌더링 속도가 훨씬 느리겠죠.</p>
<p>이번에는 장면 주위에 상자를 두어 벽과 천장에도 그림자가 생길 수 있도록 해보겠습니다.
먼저 재질의 <code class="notranslate" translate="no">side</code> 속성을 <code class="notranslate" translate="no">THREE.BackSide</code>로 설정해 외부 상자의 밖이 아닌 안을 렌더링
하도록 합니다. 바닥과 마찬가지로 그림자를 드리우지 않도록 설정하고, z-파이팅 현상을
피하기 위해 외부 상자를 바닥보다 살짝 아래에 둡니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">{
  const cubeSize = 30;
  const cubeGeo = new THREE.BoxBufferGeometry(cubeSize, cubeSize, cubeSize);
  const cubeMat = new THREE.MeshPhongMaterial({
    color: &#39;#CCC&#39;,
    side: THREE.BackSide,
  });
  const mesh = new THREE.Mesh(cubeGeo, cubeMat);
  mesh.receiveShadow = true;
  mesh.position.set(0, cubeSize / 2 - 0.1, 0);
  scene.add(mesh);
}
</code></pre>
<p>물론 조명도 <code class="notranslate" translate="no">PointLight</code>로 바꿔야죠.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">-const light = new THREE.SpotLight(color, intensity);
+const light = new THREE.PointLight(color, intensity);

....

// 조명이 위치를 확인하기 쉽도록 헬퍼 추가
+const helper = new THREE.PointLightHelper(light);
+scene.add(helper);
</code></pre>
<p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/threejs/resources/editor.html?url=/threejs/lessons/..%2Fthreejs-shadows-point-light.html"></iframe></div>
  <a class="threejs_center" href="/threejs/lessons/../threejs-shadows-point-light.html" target="_blank">새 탭에서 보기</a>
</div>

</p>
<p>GUI의 <code class="notranslate" translate="no">position</code> 속성을 조정해 조명을 움직이면 벽에 그림자가 지는 걸
확인할 수 있을 겁니다. 다른 그림자와 마찬가지로 <code class="notranslate" translate="no">near</code> 값보다 가까운
곳은 그림자가 지지 않고, <code class="notranslate" translate="no">far</code> 값보다 먼 곳은 항상 그림자가 지죠.</p>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/threejs/lessons/threejs-shadows.html" >English</a>
    <option value="/threejs/lessons/fr/threejs-shadows.html" >Français</a>
    <option value="/threejs/lessons/ja/threejs-shadows.html" >日本語</a>
    <option value="/threejs/lessons/kr/threejs-shadows.html" selected>한국어</a>
    <option value="/threejs/lessons/ru/threejs-shadows.html" >Русский</a>
    <option value="/threejs/lessons/zh_cn/threejs-shadows.html" >中文</a>
</select>


        <div id="toc">
          <ul>  <li>Three.js란?</li>
        <ul>
          <li><a href="/threejs/lessons/kr/threejs-fundamentals.html">Three.js란?</a></li>
<li><a href="/threejs/lessons/kr/threejs-responsive.html">반응형 디자인</a></li>
<li><a href="/threejs/lessons/kr/threejs-prerequisites.html">먼저 알아야 할 것들</a></li>
<li><a href="/threejs/lessons/kr/threejs-setup.html">개발 환경</a></li>
        </ul>
  <li>기본 구조</li>
        <ul>
          <li><a href="/threejs/lessons/kr/threejs-primitives.html">원시 모델</a></li>
<li><a href="/threejs/lessons/kr/threejs-scenegraph.html">씬 그래프</a></li>
<li><a href="/threejs/lessons/kr/threejs-materials.html">재질(Materials)</a></li>
<li><a href="/threejs/lessons/kr/threejs-textures.html">텍스처(Textures)</a></li>
<li><a href="/threejs/lessons/kr/threejs-lights.html">조명(Lights)</a></li>
<li><a href="/threejs/lessons/kr/threejs-cameras.html">카메라(Cameras)</a></li>
<li><a href="/threejs/lessons/kr/threejs-shadows.html">그림자(Shadows)</a></li>
<li><a href="/threejs/lessons/kr/threejs-fog.html">안개(Fog)</a></li>
<li><a href="/threejs/lessons/kr/threejs-rendertargets.html">렌더 타겟(Render Targets)</a></li>
<li><a href="/threejs/lessons/kr/threejs-custom-geometry.html">사용자 지정 Geometry</a></li>
<li><a href="/threejs/lessons/kr/threejs-custom-buffergeometry.html">사용자 지정 BufferGeometry</a></li>
        </ul>
  <li>팁</li>
        <ul>
          <li><a href="/threejs/lessons/kr/threejs-rendering-on-demand.html">불필요한 렌더링 없애기</a></li>
<li><a href="/threejs/lessons/kr/threejs-debugging-javascript.html">자바스크립트 디버깅</a></li>
<li><a href="/threejs/lessons/kr/threejs-debugging-glsl.html">GLSL 디버깅</a></li>
<li><a href="/threejs/lessons/kr/threejs-tips.html#screenshot">스크린샷 찍기</a></li>
<li><a href="/threejs/lessons/kr/threejs-tips.html#preservedrawingbuffer">캔버스 초기화 방지하기</a></li>
<li><a href="/threejs/lessons/kr/threejs-tips.html#tabindex">캔버스에서 키 입력 받기</a></li>
<li><a href="/threejs/lessons/kr/threejs-tips.html#transparent-canvas">캔버스를 투명하게 만들기</a></li>
<li><a href="/threejs/lessons/kr/threejs-tips.html#html-background">Three.js를 HTML 요소의 배경으로 사용하기</a></li>
        </ul>
  <li>최적화하기</li>
        <ul>
          <li><a href="/threejs/lessons/kr/threejs-optimize-lots-of-objects.html">요소가 많을 때 최적화하는 방법</a></li>
<li><a href="/threejs/lessons/kr/threejs-optimize-lots-of-objects-animated.html">애니메이션 요소가 많을 때 최적화하는 방법</a></li>
<li><a href="/threejs/lessons/kr/threejs-offscreencanvas.html">웹 워커에서 OffscreenCanvas 사용하기</a></li>
        </ul>
  <li>활용하기</li>
        <ul>
          <li><a href="/threejs/lessons/kr/threejs-load-obj.html">.OBJ 파일 불러오기</a></li>
<li><a href="/threejs/lessons/kr/threejs-load-gltf.html">.GLTF 파일 불러오기</a></li>
<li><a href="/threejs/lessons/kr/threejs-backgrounds.html">배경, 하늘 상자 추가하기</a></li>
<li><a href="/threejs/lessons/kr/threejs-transparency.html">물체의 투명도 설정하기</a></li>
<li><a href="/threejs/lessons/kr/threejs-multiple-scenes.html">다중 캔버스, 다중 장면 만들기</a></li>
<li><a href="/threejs/lessons/kr/threejs-picking.html">물체를 마우스로 피킹하기</a></li>
<li><a href="/threejs/lessons/kr/threejs-post-processing.html">후처리</a></li>
<li><a href="/threejs/lessons/kr/threejs-post-processing-3dlut.html">LUT 파일로 후처리 효과 적용하기</a></li>
<li><a href="/threejs/lessons/kr/threejs-shadertoy.html">쉐이더토이 쉐이더 활용하기</a></li>
<li><a href="/threejs/lessons/kr/threejs-align-html-elements-to-3d.html">HTML 요소를 3D로 정렬하기</a></li>
<li><a href="/threejs/lessons/kr/threejs-indexed-textures.html">피킹과 색상에 인덱스 텍스처 사용하기</a></li>
<li><a href="/threejs/lessons/kr/threejs-canvas-textures.html">캔버스로 동적 텍스처 만들기</a></li>
<li><a href="/threejs/lessons/kr/threejs-billboards.html">빌보드와 파사드</a></li>
<li><a href="/threejs/lessons/kr/threejs-cleanup.html">메모리 해제하기</a></li>
<li><a href="/threejs/lessons/kr/threejs-voxel-geometry.html">복셀 Geometry(마인크래프트) 만들기</a></li>
<li><a href="/threejs/lessons/kr/threejs-game.html">게임 만들기</a></li>
        </ul>
  <li>웹VR</li>
        <ul>
          <li><a href="/threejs/lessons/kr/threejs-webvr.html">VR - Basics</a></li>
<li><a href="/threejs/lessons/kr/threejs-webvr-look-to-select.html">VR - Look To Select</a></li>
<li><a href="/threejs/lessons/kr/threejs-webvr-point-to-select.html">VR - Point To Select</a></li>
        </ul>
  <li>레퍼런스</li>
        <ul>
          <li><a href="/threejs/lessons/kr/threejs-material-table.html">재질(Material) 속성표</a></li>
        </ul></ul>
<ul>
  <li>바로가기</li>
  <ul>
    <li><a href="https://github.com/gfxfundamentals/threejsfundamentals">Github</a></li>
    <li><a href="https://threejs.org">Three.js</a></li>
    <li><a href="https://threejs.org/docs/">Three.js docs</a></li>
  </ul>
</ul>

        </div>
    </div>
    <div class="lesson-comments">
        
    <div>
      <a href="http://stackoverflow.com/questions/tagged/three.js">Stackoverflow</a>
      /
      <a href="http://github.com/greggman/threefundamentals/issues">Github</a>
    </div>
  

        <div id="disqus_thread"></div>
        <script type="text/javascript">
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'threejsfundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'Three.js 그림자';
            var disqus_title = 'Three.js 그림자';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("threejsfundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script src="/3rdparty/jquery-3.3.1.slim.min.js"></script>
<script src="/threejs/lessons/resources/prettify.js"></script>
<script src="/threejs/lessons/resources/lesson.js"></script>
<script>
(function() {
  if (window.location.hostname.indexOf("threejsfundamentals.org") < 0) {
      return;
  }

  function addScript(src, fn) {
    const script = document.createElement('script');
    const firstScript = document.getElementsByTagName('script')[0];
    script.async = true;
    script.defer = true;
    if (fn) {
      script.addEventListener('load', fn);
    }
    script.src = src;
    firstScript.parentNode.insertBefore(script, firstScript);
  }

  addScript('//cdn.webglstats.com/stat.js');
  addScript('https://www.googletagmanager.com/gtag/js?id=UA-120733518-1', () => {
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-120733518-1');
  });
}());
</script>


</html>



